package termProject;

import javafx.beans.property.SimpleStringProperty;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.stage.Stage;
import javafx.util.Callback;
import javax.swing.*;
import java.io.IOException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import static javax.swing.JOptionPane.showMessageDialog;

public class CustomerQuery {

    /**
     * Variables for FXML controllers, tableview for customer data, and for selecting an item from the tableview.
     */
    //<editor-fold desc="Variables folded">
    public Button btnAppointments;
    public Label labelTables;
    public Label labelCurrentPlace;
    public Button btnLogout;
    public Button btnCustomerDelete;
    public Button btnCustomerModify;
    public Label labelNav;
    public Button btnRefresh;
    @FXML
    private Button btnHome;
    @FXML
    //Changed from nothing to <ObservableList>
    private TableView<ObservableList> customersTable;
    @FXML
    public Button btnCustomerAdd;
    @FXML
    public Button btnCustomers;
    Object selectedItem;
    String[] selectedArr;
    //</editor-fold
    //-------------------------------------------------------------------------------

    /**
     * Accept parameters and uses them to perform a query and INSERT info as a new record into the customers table.
     * @param customerName name of customer
     * @param customerAddress address of customer
     * @param customerPostal postal code of customer
     * @param customerPhone phone number of customer
     * @param createDate date the customer record is made
     * @param createdBy who made the customer record
     * @param lastUpdate the last updated datetime of the record, which here will be the same as createDate
     * @param lastUpdatedBy who last updated the record, which here will be the same as createdBy
     * @param divisionID int that corresponds to the State/Province name as defined by the DB
     */
    public static void customerInsert(String customerName, String customerAddress, String customerPostal, String customerPhone, String createDate, String createdBy, String lastUpdate, String lastUpdatedBy, int divisionID) throws SQLException {
        String sql = "INSERT INTO customers (Customer_Name, Address, Postal_Code, Phone, Create_Date, Created_By, Last_Update, Last_Updated_By, Division_ID) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        ps.setString(1,customerName);
        ps.setString(2,customerAddress);
        ps.setString(3,customerPostal);
        ps.setString(4,customerPhone);
        ps.setString(5,createDate);
        ps.setString(6, createdBy);
        ps.setString(7, lastUpdate);
        ps.setString(8,lastUpdatedBy);
        ps.setInt(9, divisionID);
        ps.executeUpdate();
        //int rowsAffected = ps.executeUpdate(); Redundant, converted to inline return.
        //return rowsAffected;
    }

    /**
     * Performs a query to update a customer record based on the selection in the tableview.
     * @param customerName name of customer
     * @param customerAddress address of customer
     * @param customerPostal postal code of customer
     * @param customerPhone phone number of customer
     * @param lastUpdate the last updated datetime of the record
     * @param lastUpdatedBy who last updated the record
     * @param divisionID int that corresponds to the State/Province name as defined by the DB
     * @param customerID int ID of the customer, auto-generated by the DB and received from a String array of the selected item in the tableview.
     */
    public static void customerUpdate(String customerName, String customerAddress, String customerPostal, String customerPhone, String lastUpdate, String lastUpdatedBy, int divisionID, int customerID) throws SQLException {
        String sql = "UPDATE customers SET Customer_Name = ?, Address = ?, Postal_Code = ?, Phone = ?, Last_Update = ?, Last_Updated_By = ?, Division_ID = ? WHERE Customer_ID = ?";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        ps.setString(1, customerName);
        ps.setString(2, customerAddress);
        ps.setString(3, customerPostal);
        ps.setString(4, customerPhone);
        ps.setString(5, lastUpdate);
        ps.setString(6, lastUpdatedBy);
        ps.setInt(7,divisionID);
        ps.setInt(8,customerID);
        ps.executeUpdate();
    }

    /**
     * Performs a query to delete a record based on the unique customer ID.
     * Due to Foreign Key restraints, it first deletes all Appointments with the customerID parameter.
     * @param customerID Unique customer ID auto-generated from the DB
     */
    public static void customerDelete(int customerID) throws SQLException {
        //WORKS
        CustomerQuery.customerDeleteAppointment(customerID);
        String sql = "DELETE FROM customers WHERE Customer_ID = ?";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        ps.setInt(1, customerID);
        ps.executeUpdate();
    }

    /**
     * Uses the customerID to query the DB and delete all appointments with that customer ID.
     * @param customerID Unique customer ID auto-generated from the DB, obtained at the same time as the customerDelete function.
     */
    public static void customerDeleteAppointment(int customerID) throws SQLException {
        //WORKS
        String sql = "DELETE FROM appointments WHERE Customer_ID = ?";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        ps.setInt(1,customerID);
        ps.executeUpdate();
    }

    /**
     * Queries for ALL info from the customers table.
     * @return returns a result set of the query.
     */
    public static ResultSet select() throws SQLException {
        String sql = "SELECT * FROM customers";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        return ps.executeQuery();
    }

    /**
     * Returns the state ID number from the DB. Defaults to -1 as the value if the name is not found.
     * @param state state name provided for the query.
     * @return returns and integer corresponding to the State parameter, based on the DB.
     */
    public static int selectDivisionID(String state) throws SQLException {
        String sql = "SELECT Division_ID FROM first_level_divisions WHERE Division = ?";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        ps.setString(1,state);
        ResultSet rs = ps.executeQuery();
        int divisionID = -1;
        while(rs.next()){
            divisionID = rs.getInt("Division_ID");
        }
        return divisionID;
    }

    /**
     * Allows the program to retrieve a state name based on the input ID.
     * @param division_id ID that should correspond to a state name.
     * @return Returns the state name as a String based on the division ID.
     */
    public static String selectDivision(int division_id) throws SQLException {
        String sql = "SELECT Division FROM first_level_divisions WHERE Division_ID = ?";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        ps.setInt(1,division_id);
        ResultSet rs = ps.executeQuery();
        String division = "Division not found.";
        while(rs.next()){
            division = rs.getString("Division");
        }
        return division;
    }

    /**
     * Gets the Country name based on the state parameter by querying a JOIN of the countries and first-level-divisions tables.
     * @param state name of a state
     * @return Returns the name of the Country that the state parameter matches with.
     */
    public static String selectCountry(String state) throws SQLException {
        String sql = "SELECT Country FROM first_level_divisions as f INNER JOIN countries as c ON f.Country_ID = c.Country_ID WHERE Division = ?";
        PreparedStatement ps = JDBC.connection.prepareStatement(sql);
        ps.setString(1,state);
        ResultSet rs = ps.executeQuery();
        String country = "State not found.";
        while(rs.next()){
            country = rs.getString("Country");
        }
        return country;
    }
    //-------------------------------------------------------------------------------

    /**
     * Loads the scene based on screenName parameter and then closes the original stage window.
     * @param screenName name of the FXML file to load
     */
    public void loadScreen(String screenName) throws IOException {
        FXMLLoader screenLoader = new FXMLLoader(login_screen.class.getResource(screenName));
        Parent screenRoot = screenLoader.load();
        Stage screenStage = new Stage();
        screenStage.setScene(new Scene(screenRoot));
        screenStage.setTitle("Term Project Application");
        screenStage.show();

        Stage closeStage = (Stage) btnHome.getScene().getWindow();
        closeStage.close();
    }

    /**
     * Logs the user out of the program by loading the login_screen. Sets the loggedUser variable in login_screen to null.
     */
    public void logoutClick() throws IOException {
        int confirmBtn = JOptionPane.YES_NO_OPTION;
        int resultBtn;
        if (login_screen.isEnglish()){
            resultBtn = JOptionPane.showConfirmDialog(null, "Are you sure you want to logout?", "Warning", confirmBtn);
        }
        else {
            resultBtn = JOptionPane.showConfirmDialog(null, "Êtes-vous sûr de vouloir vous déconnecter?", "Avertissement", confirmBtn);
        }
        if (resultBtn == JOptionPane.YES_OPTION) {
            login_screen.unsetUsername();
            loadScreen("login_screen.fxml");
        }
    }
    /**
     * Loads the home page by passing the FXML filename to loadScreen.
     */
    public void homeClick() throws IOException {
        loadScreen("home_screen.fxml");
    }

    /**
     * Loads the appointments page by passing the FXML filename to loadScreen.
     */
    public void appointmentsClick() throws IOException {
        loadScreen("appointments_screen.fxml");
    }

    /**
     * Loads the customer-add page by passing the FXML filename to loadScreen.
     */
    public void customerAddClick() throws IOException {
        FXMLLoader partLoader = new FXMLLoader(getClass().getResource("customer_add.fxml"));
        Parent partRoot = partLoader.load();
        Stage partStage = new Stage();
        partStage.setScene(new Scene(partRoot));
        partStage.show();
    }

    /**
     * Takes the selected row of the tableview and loads that data using the initCustomerData method (in modify Customer)
     * Loads the customer modify scene.
     */
    public void customerModifyClick() {
        try {
            selectedItem = customersTable.getSelectionModel().getSelectedItem();
            if (selectedItem != null){
                String selectedString = selectedItem.toString();
                selectedString = selectedString.substring(1,selectedString.length()-1);
                selectedArr = selectedString.split(",");
                //Lambda?
                selectedArr = Arrays.stream(selectedArr).map(String::trim).toArray(String[]::new);

                FXMLLoader customerLoader = new FXMLLoader(getClass().getResource("customer_modify.fxml"));
                Parent customerRoot = customerLoader.load();
                Stage customerModifyStage = new Stage();
                customerModifyStage.setScene(new Scene(customerRoot));

                modifyCustomerController modControl = customerLoader.getController();
                modControl.initCustomerData(selectedArr);

                customerModifyStage.show();
            }
            else {
                if (login_screen.isEnglish()){
                    showMessageDialog(null, "Select a row to modify.");
                }
                else {
                    showMessageDialog(null, "Sélectionnez une ligne à modifier.");
                }
            }
        }
        catch (Exception e) {
            if (login_screen.isEnglish()){
                showMessageDialog(null, "Select a row to modify.");
            }
            else {
                showMessageDialog(null, "Sélectionnez une ligne à modifier.");
            }
        }
    }

    /**
     * Retrieves the customer ID of the selected row and using it in a query to delete the records of the customer of that ID.
     */
    public void customerDeleteClick() {
        try {
            selectedItem = customersTable.getSelectionModel().getSelectedItem();
            if (selectedItem != null) {
                int confirmBtn = JOptionPane.YES_NO_OPTION;
                int resultBtn;
                if (login_screen.isEnglish()){
                    resultBtn = JOptionPane.showConfirmDialog(null, "Are you sure you want to delete this customer?", "Warning", confirmBtn);
                }
                else {
                    resultBtn = JOptionPane.showConfirmDialog(null, "Voulez-vous vraiment supprimer ce client?", "Avertissement", confirmBtn);
                }

                if (resultBtn == JOptionPane.YES_OPTION) {
                    String selectedString = selectedItem.toString();
                    selectedString = selectedString.substring(1, selectedString.length() - 1);
                    selectedArr = selectedString.split(",");
                    //Lambda?
                    selectedArr = Arrays.stream(selectedArr).map(String::trim).toArray(String[]::new);
                    String cusID = selectedArr[0];
                    int customerID = Integer.parseInt(cusID);

                    CustomerQuery.customerDelete(customerID);
                    refreshTable();

                    //TODO future: actually check if it was deleted. Select on customers to see if appointmentID exists. Write an error message if it's still there.
                    if (login_screen.isEnglish()){
                        showMessageDialog(null, "Customer deleted.");
                    }
                    else {
                        showMessageDialog(null, "Client supprimé.");
                    }
                }
            }
            else {
                if (login_screen.isEnglish()){
                    showMessageDialog(null, "Select a row to modify.");
                }
                else {
                    showMessageDialog(null, "Sélectionnez une ligne à modifier.");
                }
            }
        }
        catch (SQLException ex) {
            if (login_screen.isEnglish()){
                showMessageDialog(null, "Select a row to delete.");
            }
            else {
                showMessageDialog(null, "Sélectionnez une ligne à supprimer.");
            }
            throw new RuntimeException(ex);
        }
    }

    //-------------------------------------------------------------------------------
    /**
     * Gets data for all customers.
     * Dynamically creates the columns and fills them for customers, based on the Result Set queried.
     * Receives the data and then puts it into the observable list, then setting the Tableview with that list.
     */
    public void getData() {
        try {
            ObservableList<ObservableList> data = FXCollections.observableArrayList();
            data.clear();
            customersTable.getItems().clear();
            customersTable.getColumns().clear();
            ResultSet rs = CustomerQuery.select();

            for (int i = 0; i < rs.getMetaData().getColumnCount(); i++){
                final int j = i;
                TableColumn tblCol = new TableColumn(rs.getMetaData().getColumnName(i+1));
                tblCol.setCellValueFactory((Callback<TableColumn.CellDataFeatures<ObservableList, String>, ObservableValue<String>>) param -> new SimpleStringProperty(param.getValue().get(j).toString()));
                customersTable.getColumns().addAll(tblCol);
            }
            while(rs.next()) {
                ObservableList<String> row = FXCollections.observableArrayList();
                for (int i=1; i <= rs.getMetaData().getColumnCount();i++){
                    row.add(rs.getString(i));
                }
                data.add(row);
            }
            customersTable.setItems(data);
        }
        catch (Exception e){
            e.printStackTrace();
            if (login_screen.isEnglish()){
                showMessageDialog(null, "Error getting data.");
            }
            else {
                showMessageDialog(null, "Erreur lors de l'obtention des données.");
            }
        }
    }

    /**
     * Executes the getData function to reload the table.
     * This function is mainly called with the FXML refresh-button.
     */
    public void refreshTable(){
        getData();
    }
    //-------------------------------------------------------------------------------

    /**
     * Calls the getData method when the customer screen is loaded.
     * Translates all labels and text to French when applicable.
     */
    public void initialize() {
        getData();
        if (!login_screen.isEnglish()){
            //TODO: labelnav is too long in french, fix.
            labelNav.setText("La navigation");
            btnHome.setText("Maison");
            labelTables.setText("Les tables");
            btnCustomers.setText("Clients");
            btnAppointments.setText("Rendez-vous");
            btnLogout.setText("Se déconnecter");
            labelCurrentPlace.setText("Clients");
            btnRefresh.setText("Rafraîchir");
            btnCustomerAdd.setText("Ajouter");
            btnCustomerModify.setText("Modifier");
            btnCustomerDelete.setText("Supprimer");
        }
    }
}
